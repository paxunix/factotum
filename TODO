- how to simplify debugging of Fcommands?
    - modify Util.getCodeString() to take an options object.  If it has the
      'debug' property, insert the break-into-debugger statement at the
      start of the Fcommand function body.
    - when about to parse opts for an Fcommand, always include a --debug
      option.  It takes a value (defaults to "").  If no value, enable
      debugging of the Fcommand itself.  If value is "bg" enable debugging
      of the code passed from the Fcommand to the background page.

- what if the Fcommands were actually HTML documents?
    - or just save them as a Blob into an indexeddb (supported as of Chrome
      38) and use URL.createObjectURL(blob) to get a URL from it
        - will this work?  if the import is into the background page, it
          will generate URLs with the extension page's origin and probably
          not be importable into the page.
            - probably never import an FCommand into the background page.
              But what if it really just needs extension APIs?  There's no
              need to load it into the content page at all, then pass JS
              back to be executed in background anyway.
    - this leads to really cool things:
        - since the Fcommand is an HTML document, then you can use <meta> to
          specify the metadata for the Fcommand, and programmatically
          extract it.  This should cut down significantly on the validation
          needed for Fcommands:  the browser's document parser does much of
          it already.
            - Factotum's background script will have to create a document
              fragment in order to extract the metadata, but that's a
              one-time fixed cost at first installation of an Fcommand.
                - What about modifying it?  Do we want to support local
                  modifications?
    - then, the document we actually import could even include
      Factotum-specific stuff after, in order to do any additional setup.
    - this handles de-duping of resources, allows for Fcommands to include
      and dependencies they want via the same import mechanism.
            - VERIFIED: this means sending the Fcommand HTML to the content
              script every time and it creates a Blob URL.  Actually, it
              should be able to revoke it once the import is actually loaded,
              because the document will then already be part of the page.
              Then the Fcommand itself is executed in the onload for the
              Fcommand import doc.
                - if an Fcommand is updated, though, and it had been
                  executed on that page, it means the old Fcommand content
                  will be used, not the new one until the page is loaded.
                    - if the update timestamp on the fcommand is known, it
                      can be used by the content script to determine if
                      there is new content for that Fcommand and it can do a
                      new import.
        - because then the author can specify all the crazy dependencies
          they want and we don't have to define a special data format to do
          it.  They can even define custom markup that they can then clone
          wholesale into the parent document to use from within their
          Fcommand script.
    - XXX:  just always run them in a page.  Then you don't need this.
      should be able to import an Fcommand into the background page also, in
      case it requires nothing but extension APIs.  That has to run in some
      kind of sandbox so you can't crash the extension.  May be as simple as
      evaling the script in a sandboxed iframe within the extension's
      background page.
        - seems web workers are also a possibility, although then you don't
          have access to window property (so you basically get no UI stuff).
          http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/
    - so the background page can collect the metadata from the Fcommand
      document with:
              fcommandDoc=jQuery("<div>").append(jQuery.parseHTML(jQuery));
              guid=fcommandDoc.find("meta[name=guid]:first")[0].prop("content");
            in order to extract the data for the IndexedDB tables.
        - can parse HTML using DOMParser:
            doc = (new DOMParser).parseFromString('<div>testing <script>alert("testing");</script> 1 2 3</div>', "text/html");
            - no scripts are evaluated; it just builds the DOM
    - any embedded scripts won't be eval'd in that case (which is what we
      want), but they _will_ be eval'd when injected into the page via
      import.  That's why the Fcommand script itself is marked with a bogus
      mime-type:  you don't want it executed on insertion (XXX:  we're going
      to do this with <template> instead.  Then you _can_ distinguish
      between run-on-import and run-as-fcommand-after-import).  Hmm, or do
      you?
      Actually, you could let it eval as a normal script.  Any other scripts
      were already eval'd (even as imports), and if you need to yoink in
      content from the import, you have to do it anyway when the Fcommand
      runs.  So, it probably makes the most sense to just make the script be
      as-is, no mime-type fuckery.
        - don't need an id on the script tag either, since it's simply going
          to be evaluated in-place during import--no need to reference it
          and eval it later.  Actually, this won't work:  we have no control
          over wrapping it in a script to catch errors, etc.
          So, you still need the fake mime-type script tag with ID, but if
          you emit regular script tags, be aware they will execute upon
          import of the document (this can be handy for some things, like an
          Fcommand to load jQUery into a page and notify when it's done)
          - might be able to remove the Fcommand script from the document
            before importing it; that way you don't bloat the page by
            duplicating it.  Same for the minimist-opts block.
                fcommandbody = impdoc.find("script#fcommand").remove().text();

    - figure out what happens if the content script injects the <link>
      import and it runs a script.  Does the script get run in the
      content-script's context or in the page's context?  This would matter
      if they didn't put <template> in (for which there is a valid reason:
      you're loading a script via import, but you want something done as
      soon as it finishes)
        - this seems obvious:  it has to run in page context since that's
          the document into which it was injected

    - note that the HTML document that contains an Fcommand is just a
      delivery document.  Data is extracted from it and put into a DB and
      then various parts of it are rearranged and injected into other
      documents as needed.
        - there is no need to import the entire document when we had to
          extract data from it and store it anyway.  But does it matter?
          These won't be huge documents.

- would be cool to flag an fcommand as taking no parameters and being able
  to be run from the context menu.  Then we can populate the context menu
  with those Fcommands and when you click one, it runs it as if you had
  typed its name in the omnibox

- could just use the chrome filesystem sync api to store the factotum
  commands on the user's google drive and then make them available in all
  clients
    - should be able to toggle which ones you want sync'd and which you
      don't (so you can have a set of scripts just for work that aren't
      sync'd to your home account)?  Or just handle this via chrome profiles?

- should the DB have a separate table of guid->code, rather than storing the
  code in the same table as the metadata?
    - if separate, you only ever read in the code for the function about to
      be executed, saving memory.  Whereas if the code is in the same table,
      then when getting commands by prefix (or even when listing all
      commands), you have to pull all the code as well, even if it's not
      going to be used, which is wasteful.

- create class that manages Fcommands  FcommandManager
    - Fcommands are stored in an IndexedDB
      - indexed on unique guid
      - indexed on name
    - constructor
        - sets up objectstore and indexes
    - addCommand
        - saves the given Fcommand
    - deleteCommand
        - removes the given Fcommand
    - getCommandsByName
        - returns list of Fcommand objects given a name.

- Fcommand datastore
    - names[] : indexed
    - guid : indexed, unique key
    - original document string
    - description
    - optSpec
    - help document string?
    - cooked document string?
    - all of the metadata fields (if showing them separately, might as well
      make them separate fields, although it seems silly to store the
      original document then duplicate all its data in separate fields)
    - enabled
    - priority[]: integer associated with name[].  Lower number == highest
      priority.  Priorities are per name, not per Fcommand (i.e. you may have 2 Fcommands with the name "foo", and you want one to have higher priority than the other.  Priority is used only to determine the order of the Fcommand names in the omnibox dropdown)


----------------


- provide a management interface on the options page just for F commands
    - shows a list of commands
    - support enabling/disabling F commands
    - support enable/disable of individual aliases for Fcommands???
        - useful if you have an Fcommand that supplies an alias you don't
          want because it's supplied by a different Fcommand
    - shows their help content
    - editing commands
    - exporting commands

- internal Fcommand 'help' should pull up the help content for the given
  Fcommand
    - do this with a default --help option on an Fcommand

- support commands from non-local sources
    - e.g. specifying a URL will pull the Fcommand from the URL and use it.
        - need to specify the data format.
    - can these be edited locally???

- popup page could show the last N Fcommands and/or the most frequently used
  Fcommands

- need an option to toggle error notifications on/off?

- useful to make distinction between commands that require the current
  page's context and those that don't?
    - e.g. if an Fcommand is only opening a new tab, there's no need for it
      to run within the current page--it can run fine in the background page
    - too difficult to explain to users?

- fcommand's response object could have an extra field that if somehow set
  by the Fcommand's code (and the code succeeded) would indicate the
  extension should popup a notification with custom content.

- explore using a page action instead of a browser action for Factotum,
  since it (currently) requires a page in order to do pretty much anything.
  It would be great if there is a way to trigger the page action popup
  (since it's not possible to trigger it for the browser action).  Then it
  could be used for notifications, return statuses, etc.

- thinking internal Fcommands should be handled entirely differently.  They
  don't exist as Fcommands.  They're hardcoded and cannot be overridden or
  reprioritized.  There aren't many of them (maybe even only "help").  They are
  detected when the command line is parsed and before it is dispatched.
  This simplifies the Fcommand.execute property logic.

- loading a predefined Fcommand from the extension itself (run this in the
  background page after you know the tab ID of the page that should get the
  import doc):
  chrome.tabs.sendMessage(760, { fcommandId: "123", documentURL: chrome.runtime.getURL("example/load-jquery.xxxhtml")}, Factotum.responseHandler)
    - note that the URL path within the extension must be in the manifest's
      web_accessible_resources list

About the importing

DONE
- while there is no reason to import the exact document as given, it is
  easiest to import the entire thing.  A future optimization could
  extract and remove some data, yielding a smaller document for import.
