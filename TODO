- allow for any JS (or CSS) to be loaded into the page (via
  chrome.tabs.executeScript or chrome.tabs.insertCSS).  Each Fcommand gets a
  new property that is an array of things to be injected into the page
  immediately before that command executes.
    - may need to guard against multiple inclusion.

- prior to each Fcommand's execution, load any requested additional
  functionality into the current page.

- provide a management interface on the options page just for F commands
    - shows a list of commands
    - support enabling/disabling F commands
    - support enable/disable of individual aliases for Fcommands???
        - useful if you have an Fcommand that supplies an alias you don't
          want because it's supplied by a different Fcommand
    - shows their help content
    - editing commands
    - exporting commands

- internal Fcommand 'help' should pull up the help content for the given
  Fcommand

- support commands from non-local sources
    - e.g. specifying a URL will pull the Fcommand from the URL and use it.
        - need to specify the data format.
    - can these be edited locally???

- support commands that aren't commands at all but are actually JS libs?
  Same for CSS?
    - this provides a mechanism to load common libs locally, rather
      than from an external source upon use.
    - these can be requested for load by an Fcommand; give them aliases?  No
      need: they can just be requested via URL, then cached.
    - cache them?  Then only refresh them whenever the Factotum extension is
      activated?  If so, then maybe it's not necessary to have commands that
      aren't commands--they can be demand-loaded via the above mechanism and
      since they're cached, subsequent loads will be fast.

- popup page could show the last N Fcommands and/or the most frequently used
  Fcommands

- description property should always be a string.  Need to provide some way
  of indicating it is actually JS.  Storing every property as a string (or
  at least, a non-function) will make persistence easier).

- since we are injecting the Fcommand into the current page as a content
  script, it means Fcommands won't work when run on chrome: URL pages.
  Workarounds:
    - open a new tab, then close it when the Fcommand is done.  This looks
      messy, but may be the cleanest and most stable approach.
    - run it in the context of the background page.  This could introduce
      instability if the Fcommand does anything except read data.

- need an option to toggle error notifications on/off?

- since chrome.tabs.executeScript doesn't support remote URLs, we need to do
  an XHR from the background page to pull the script content, then inject
  that into the page

- Fcommand 'execute' property can be a function or a string.  The only time
  it will be a function is if it's an internally-implemented Fcommand,
  because in all other cases, the code will have come from a string.  Since
  that's the case, maybe we only need internal functions to run within the
  background page, rather than the content page.  E.g.  the 'help' Fcommand
  should popup some window with information about the given command.  There
  is no need for it to run in the content page since it won't need access to
  anything there.  Is it true that will be the case for all internal
  Fcommands?
    - actually, it makes a lot of sense to run internal Fcommands from the
      background page:  we want them to be available everywhere, even on
      internal chrome pages (which they actually can't be anyway).
    - this means the _converted_-key stuff can probably go away because any
      internal functions don't need to be persisted (if it's an actual
      function, it is defined by the extension itself and so doesn't need to
      be stored).

- should move away from using localStorage for Fcommands since we're stuck
  at 2.5MB:
  http://code.google.com/p/chromium/issues/detail?id=58985 Looks like
  IndexedDB or FileSystem is the best candidate.  Given that we probably
  don't need anything approaching a DB, FileSystem might be tidiest.

- useful to make distinction between commands that require the current
  page's context and those that don't?
    - e.g. if an Fcommand is only opening a new tab, there's no need for it
      to run within the current page--it can run fine in the background page
    - too difficult to explain to users?

- don't call deleteAll in test specs--that will blow away any saved
  Fcommands.  Modify all test to use conspicuous Fcommand names (like
  _FACTOTUM_TEST_blahblah) and only remove those before each test.

- Fcommands.dispatch belongs in Factotum, not Fcommands.

- fcommand's response object could have an extra field that if somehow set
  by the Fcommand's code (and the code succeeded) would indicate the
  extension should popup a notification with custom content.

- to the Fcommand, pass both the actual Fcommand name and the one that was
  used to look up the actual name.  e.g. "hel" for "help".

- it may be possible to have the spec runner page load a separate page before
  executing Fcommands.  Then, force that page's tab to be the current tab
  when the test runs.  This will hopefully cause the Fcommand to be run in
  that page, rather than trying (and failing) to run in the spec page.

- explore using a page action instead of a browser action for Factotum,
  since it (currently) requires a page in order to do pretty much anything.
  It would be great if there is a way to trigger the page action popup
  (since it's not possible to trigger it for the browser action).  Then it
  could be used for notifications, return statuses, etc.
