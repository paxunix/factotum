- is it feasible/sensible to use HTML imports to do the actual JS importing?
  Also for any external resources the injected script requires?  Maybe
  bundle the whole set up in a document and import the doc?
    - can import a data URL?  Doesn't seem to be possible (Chrome complained
      with net::ERR_INVALID_URL

- what if the Fcommands were actually HTML documents?
    - when installed, they're written to a filesystem object
    - when run, that file system object is used as an href and imported into
      the current document
        - what if you want to import it into the background page?  Or an
          arbirary background page?  Can you dynamically create a background
          page?
    - or just save them as a Blob into an indexeddb (supported as of Chrome
      38) and use URL.createObjectURL(blob) to get a URL from it
        - will this work?  if the import is into the background page, it
          will generate URLs with the extension page's origin and probably
          not be importable into the page.
            - probably never import an FCommand into the background page.
              But what if it really just needs extension APIs?  There's no
              need to load it into the content page at all, then pass JS
              back to be executed in background anyway.
    - this leads to really cool things:
        - since the Fcommand is an HTML document, then you can use <meta> to
          specify the metadata for the Fcommand, and programmatically
          extract it.  This should cut down significantly on the validation
          needed for Fcommands:  the browser's document parser does much of
          it already.
            - Factotum's background script will have to create a document
              fragment in order to extract the metadata, but that's a
              one-time fixed cost at first installation of an Fcommand.
                - What about modifying it?  Do we want to support local
                  modifications?
    - then, the document we actually import could even include
      Factotum-specific stuff after, in order to do any additional setup.
    - this handles de-duping of resources, allows for Fcommands to include
      and dependencies they want via the same import mechanism.
            - VERIFIED: this means sending the Fcommand HTML to the content
              script every time and it creates a Blob URL.  Actually, it
              should be able to revoke it once the import is actually loaded,
              because the document will then already be part of the page.
              Then the Fcommand itself is executed in the onload for the
              Fcommand import doc.
                - if an Fcommand is updated, though, and it had been
                  executed on that page, it means the old Fcommand content
                  will be used, not the new one until the page is loaded.
                    - if the update timestamp on the fcommand is known, it
                      can be used by the content script to determine if
                      there is new content for that Fcommand and it can do a
                      new import.
        - because then the author can specify all the crazy dependencies
          they want and we don't have to define a special data format to do
          it.  They can even define custom markup that they can then clone
          wholesale into the parent document to use from within their
          Fcommand script.
    - how to handle Fcommands that need extension-level permissions to do
      something, but within the context of a page?  They need to tell the
      background script to do something on their behalf (like execute
      arbitrary JS), and return the results when ready.  This seems mostly
      straightforward:
        - the background script has a listener for requests from the content
          script
        - content script sends a request whose payload is arbitrary JS
        - bg script receives the payload, executes the JS in a sandbox,
          sends the results back to the content script (or to the page?)
    - XXX:  just always run them in a page.  Then you don't need this.
      should be able to import an Fcommand into the background page also, in
      case it requires nothing but extension APIs.  That has to run in some
      kind of sandbox so you can't crash the extension.  May be as simple as
      evaling the script in a sandboxed iframe within the extension's
      background page.
        - seems web workers are also a possibility, although then you don't
          have access to window property (so you basically get no UI stuff).
          http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/
    - so the background page can collect the metadata from the Fcommand
      document with:
              fcommandDoc=jQuery("<div>").append(jQuery.parseHTML(jQuery));
              guid=fcommandDoc.find("meta[name=guid]:first")[0].prop("content");
            in order to extract the data for the IndexedDB tables.
        - can parse HTML using DOMParser:
            doc = (new DOMParser).parseFromString('<div>testing <script>alert("testing");</script> 1 2 3</div>', "text/html");
            - no scripts are evaluated; it just builds the DOM
    - any embedded scripts won't be eval'd in that case (which is what we
      want), but they _will_ be eval'd when injected into the page via
      import.  That's why the Fcommand script itself is marked with a bogus
      mime-type:  you don't want it executed on insertion (XXX:  we're going
      to do this with <template> instead.  Then you _can_ distinguish
      between run-on-import and run-as-fcommand-after-import).  Hmm, or do
      you?
      Actually, you could let it eval as a normal script.  Any other scripts
      were already eval'd (even as imports), and if you need to yoink in
      content from the import, you have to do it anyway when the Fcommand
      runs.  So, it probably makes the most sense to just make the script be
      as-is, no mime-type fuckery.
        - don't need an id on the script tag either, since it's simply going
          to be evaluated in-place during import--no need to reference it
          and eval it later.  Actually, this won't work:  we have no control
          over wrapping it in a script to catch errors, etc.
          So, you still need the fake mime-type script tag with ID, but if
          you emit regular script tags, be aware they will execute upon
          import of the document (this can be handy for some things, like an
          Fcommand to load jQUery into a page and notify when it's done)
          - might be able to remove the Fcommand script from the document
            before importing it; that way you don't bloat the page by
            duplicating it.  Same for the minimist-opts block.
                fcommandbody = impdoc.find("script#fcommand").remove().text();

    - figure out what happens if the content script injects the <link>
      import and it runs a script.  Does the script get run in the
      content-script's context or in the page's context?  This would matter
      if they didn't put <template> in (for which there is a valid reason:
      you're loading a script via import, but you want something done as
      soon as it finishes)
        - this seems obvious:  it has to run in page context since that's
          the document into which it was injected

    - note that the HTML document that contains an Fcommand is just a
      delivery document.  Data is extracted from it and put into a DB and
      then various parts of it are rearranged and injected into other
      documents as needed.
        - there is no need to import the entire document when we had to
          extract data from it and store it anyway.  But does it matter?
          These won't be huge documents.

- need a way to inject into all frames within a page?  Can already have the
  content script inserted into all frames (via manifest properties), but
  there can only be one listener per tab.  How to specify which frame should
  run the Fcommand?  Should it always be the top frame?  Should an Fcommand
  be able to decide which frame should run it?

- NOW:  so the content script should be able to pass a function to the bg page,
  which runs it.  That function returns a result back to the content page
  via message passing.  The function itself gets run inside a web worker in
  the bg page (so it has very limited access to the extension, but does have
  access to chrome APIs -- have to test this).
    - this is how you get your content script to, say, open a new tab, or
      make a cross-origin ajax request and get the results
    - doesn't work because web workers have no access to chrome APIs
        - so, this implies that having a web worker in the background page
          to do things is pointless.  Need to establish a cleaner context
          for evaluating code for bg Fcommands and passed from the content
          script on behalf of an Fcommand.

- would be cool to flag an fcommand as taking no parameters and being able
  to be run from the context menu.  Then we can populate the context menu
  with those Fcommands and when you click one, it runs it as if you had
  typed its name in the omnibox

- could just use the chrome filesystem sync api to store the factotum
  commands on the user's google drive and then make them available in all
  clients
    - should be able to toggle which ones you want sync'd and which you
      don't (so you can have a set of scripts just for work that aren't
      sync'd to your home account)?  Or just handle this via chrome profiles?

- should the DB have a separate table of guid->code, rather than storing the
  code in the same table as the metadata?
    - if separate, you only ever read in the code for the function about to
      be executed, saving memory.  Whereas if the code is in the same table,
      then when getting commands by prefix (or even when listing all
      commands), you have to pull all the code as well, even if it's not
      going to be used, which is wasteful.

- create class that manages Fcommands  FcommandManager
    - Fcommands are stored in an IndexedDB
      - indexed on unique guid
      - indexed on name
    - constructor
        - sets up objectstore and indexes
    - addCommand
        - saves the given Fcommand
    - deleteCommand
        - removes the given Fcommand
    - getCommandsByName
        - returns list of Fcommand objects given a name.

- Fcommand datastore
    - names[] : indexed
    - guid : indexed, unique key
    - original document string
    - description
    - optSpec
    - help document string?
    - cooked document string?
    - all of the metadata fields (if showing them separately, might as well
      make them separate fields, although it seems silly to store the
      original document then duplicate all its data in separate fields)
    - enabled
    - priority[]: integer associated with name[].  Lower number == highest
      priority.  Priorities are per name, not per Fcommand (i.e. you may have 2 Fcommands with the name "foo", and you want one to have higher priority than the other.  Priority is used only to determine the order of the Fcommand names in the omnibox dropdown)


----------------


- prior to each Fcommand's execution, load any requested additional
  functionality into the current page.

- provide a management interface on the options page just for F commands
    - shows a list of commands
    - support enabling/disabling F commands
    - support enable/disable of individual aliases for Fcommands???
        - useful if you have an Fcommand that supplies an alias you don't
          want because it's supplied by a different Fcommand
    - shows their help content
    - editing commands
    - exporting commands

- internal Fcommand 'help' should pull up the help content for the given
  Fcommand

- support commands from non-local sources
    - e.g. specifying a URL will pull the Fcommand from the URL and use it.
        - need to specify the data format.
    - can these be edited locally???

- support commands that aren't commands at all but are actually JS libs?
  Same for CSS?
    - this provides a mechanism to load common libs locally, rather
      than from an external source upon use.
    - these can be requested for load by an Fcommand; give them aliases?  No
      need: they can just be requested via URL, then cached.
    - cache them?  Then only refresh them whenever the Factotum extension is
      activated?  If so, then maybe it's not necessary to have commands that
      aren't commands--they can be demand-loaded via the above mechanism and
      since they're cached, subsequent loads will be fast.

- popup page could show the last N Fcommands and/or the most frequently used
  Fcommands

- need an option to toggle error notifications on/off?

- Fcommand 'execute' property can be a function or a string.  The only time
  it will be a function is if it's an internally-implemented Fcommand,
  because in all other cases, the code will have come from a string.  Since
  that's the case, maybe we only need internal functions to run within the
  background page, rather than the content page.  E.g.  the 'help' Fcommand
  should popup some window with information about the given command.  There
  is no need for it to run in the content page since it won't need access to
  anything there.  Is it true that will be the case for all internal
  Fcommands?
    - actually, it makes a lot of sense to run internal Fcommands from the
      background page:  we want them to be available everywhere, even on
      internal chrome pages (which they actually can't be anyway).
    - this means the _converted_-key stuff can probably go away because any
      internal functions don't need to be persisted (if it's an actual
      function, it is defined by the extension itself and so doesn't need to
      be stored).

- useful to make distinction between commands that require the current
  page's context and those that don't?
    - e.g. if an Fcommand is only opening a new tab, there's no need for it
      to run within the current page--it can run fine in the background page
    - too difficult to explain to users?

- fcommand's response object could have an extra field that if somehow set
  by the Fcommand's code (and the code succeeded) would indicate the
  extension should popup a notification with custom content.

- it may be possible to have the spec runner page load a separate page before
  executing Fcommands.  Then, force that page's tab to be the current tab
  when the test runs.  This will hopefully cause the Fcommand to be run in
  that page, rather than trying (and failing) to run in the spec page.

- explore using a page action instead of a browser action for Factotum,
  since it (currently) requires a page in order to do pretty much anything.
  It would be great if there is a way to trigger the page action popup
  (since it's not possible to trigger it for the browser action).  Then it
  could be used for notifications, return statuses, etc.

- thinking internal Fcommands should be handled entirely differently.  They
  don't exist as Fcommands.  They're hardcoded and cannot be overridden or
  reprioritized.  There aren't many of them (maybe even only "help").  They are
  detected when the command line is parsed and before it is dispatched.
  This simplifies the Fcommand.execute property logic.

- loading a predefined Fcommand from the extension itself (run this in the
  background page after you know the tab ID of the page that should get the
  import doc):
  chrome.tabs.sendMessage(760, { fcommandId: "123", documentURL: chrome.runtime.getURL("example/load-jquery.xxxhtml")}, Factotum.responseHandler)
    - note that the URL path within the extension must be in the manifest's
      web_accessible_resources list

Sending to content script in current tab:
    chrome.tabs.query({active: true}, function (tabs) { chrome.tabs.sendMessage(tabs[0].id, { documentString: "importbody", codeString: "console.log('args:',arguments); arguments[1](\"console.log('bgcode:', arguments);\")" }, Factotum.responseHandler); })

About the importing

DONE
- while there is no reason to import the exact document as given, it is
  easiest to import the entire thing.  A future optimization could
  extract and remove some data, yielding a smaller document for import.

- while the Fcommand code itself _could_ run during import (so it must be
  "hidden" in a template or expressed via an alternate <script> mime-type)
  it's a one-shot and will also not have the ability to communicate back to
  the content script.
    - since we want to allow Fcommand code to pass JS to the background
      page, the code can never be extracted from the page itself.  That is a
      huge security risk because a well-timed attacker could replace the
      Fcommand code in the page with malware which would then instead be
      passed to bg for execution.  The Fcommand can only ever come from the
      bg page.  Moreover, Fcommand authors need to be aware that they can
      pass no Javascript to bg that was embedded within the page, since that
      has to be considered potentially malicious.  We cannot prevent this,
      but they need to endeavour not to.

- flow:
    - (bg) Fcommand document ingested
    - (bg) validated and parsed
    - (bg) document is stored, metadata+Fcommand code is indexed and stored
    - (bg) Fcommand is invoked
    - (bg) parse the command line
    - (bg) send the import document, parsed command line data, and Fcommand
      code string to the content script
    - (bg) listen for response from content script
    - (cs) create a blob of the import document
    - (cs) create object url of blob
    - (cs) dynamically add blob's import <link> to document
    - (cs) once import loads, evaluate the Fcommand code string (it could be
      passed a reference to the import document, in case it needs to
      retrieve content from it; it should also receive a callback function
      that does what's needed to pass a result to the bg)
    - (cs-cb) removes the import from the document.  This may be
      controversial.  Fcommand code needs to be aware that if it has side
      effects, those will persist, even if the import is removed.
    - (cs-cb) revokes the blob URL
    - (cs-cb) send code/status/etc. back to the bg
    - (bg) receive response from content script and evaluate the code, pop a
      notification, etc.

- I'm still not settled on the best way to invoke the actual Fcommand.
    - the import doc could use top-level JS as the Fcommand and it will run
      during import.  It would then in turn pull in any dependent JS as
      needed.  If it needed to access chrome APIs, it would have to send a
      message to the bg page (with postMessage? or sendMessage?) with the
      code to execute.
        - actually, that's not helpful because the code that runs when the
          doc imports will only ever run once.  Since the Fcommand must be
          runnable again on that same page without a reload, it can't be run
          as part of the import--it needs to be executed on demand each time.
    - so, this implies using the import doc, the getting the Fcommand code
      to execute either from the import doc each time, or sent from the bg
      script.  Seems dumb to send it from the bg script when we can already
      have imported it and then just execute it from content.  Then the bg
      script only has to signal the content script to run fcommand with a
      given ID with these args, provided the Fcommand has already been
      imported.  So there's the catch.  The bg script doesn't know if the
      fcommand has already been imported into that page--it has to either
      keep track of that bookkeeping info (XXX: this seems like complexity
      that's not worthwhile), or it has to always send the fcommand data and
      the content script decides whether it has to create the one-time
      import, or it just has to execute the command with the given args.

- consider:  since the import will execute any bare <script> tags on import,
  what about having the import document execute the fcommand itself?
    - we are already crafting an augmented document using the Fcommand
      import document as a base.
    1) those scripts run on import, which means you can't rerun the same
       Fcommand again
        - what if you can remove the import, then re-import?  Would it
          ignore it because it knows you did that already?
            - if it is possible to do the re-import, then I think things
              become much easier:
                - import doc
                - inline scripts all execute (which means there has to be an
                  API for the Fcommand script(s) to pass info back to the
                  background page via an event listener in the content
                  script.  Otherwise, it functions exactly as a regular
                  script execution.  No wrapper, no nothing.  Just plain JS
                  that knows how to pass a message back to the extension and
                  have it eval a payload.
                - once done, remove the import?  How do we know when it's
                  done?  Does the Fcommand have to signal completion?  If
                  so, we can augment that during the import.  That actually
                  might have the added benefit of if there is an error, the
                  removal of the import doesn't happen, permitting some
                  in-place debugging.
            - by removing the import, you no longer have to keep track of
              whether the import was already done (to avoid bloating with
              blob urls).  What about cruft left around by the Fcommand
              scripts?  You'd have that same problem anyway if the Fcommand
              was executed in the context of the content script.  Fcommand
              JS should be written in a leave-no-trace way (unless the point
              of the Fcommand is to leave something behind, in which case it
              should guard against itself).  Since we are allowing execution
              of arbitrary JS, it's impossible to guard against all
              possibilities, so the best thing is to do nothing and just
              execute it.
            - this should also allow for removing the blob url as soon as
              the import is done.  CAN:  you can do this anyway
            - CANT:  so removing the import and re-importing with the same URL
              doesn't work--it only fires onload but doesn't re-add the
              import document.
                - CAN: so this means you can still get away with NOT tracking
                  imports and letting the scripts execute on import IF you
                  don't reuse the same import URL each time.  As long as you
                  revoke them, this shouldn't be a problem (provided they
                  actually ARE cleaned up at revoke time)
                    - this means you don't need the blob cache and the
                      content script never actually executes any JS--only
                      the import does.  BUT:  it can send a message to the
                      content script who can then pass it on to the
                      background page.  That IS a giant security
                      hole because you then let any web page at all send
                      arbitrary JS to the background page to
                      execute--without any oversight or knowledge that it's
                      happening.  Fcommand JS can only be run by the content
                      script upon direction by the background page (most
                      likely due to invocation from the omnibox)
                    - this also means you can't have the content script pull
                      the Fcommand JS from the import.  It has to get it ALL
                      from the background page where the original Fcommand
                      data was from.  PUlling any of it at all from the
                      imported document after import means pulling it from
                      the page itself, which means a script on the page
                      could have modified the JS in the import doc and now
                      it will execute with full privileges of the extension.
                        - so now, why use an import doc?

        Note:  link.onload is fired even if the import was previously done
        (and no scripts in the import doc are re-executed)

    - CAN:  revoke the blob url after the import is loaded (i.e. at the end
      of the onload event)
        - this has ramifications if you wanted to debug it because it will
          no longer exist.  Actually, you can't do that anyway without the
          'debugger' keyword because any <script> tags execute during load
