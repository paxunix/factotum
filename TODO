- should prevent multiple simultaneous invocations of the same Fcommand.
    - this is possible because the Fcommand could start an async action and
      then call the onSuccess function some time in the future
    - in the meantime, invoking the Fcommand again may cause strange things
      to happen

- However, how do you then pass the command line to it?
    - you could bake the parameters as a JSON blob into the DOM of
      the import document, then the Fcommand has to use a particular
      name in order to reference them.  This sucks because fixed
      names are unpleasant to work with.
    - you can't pass the parameters stringified as query string arguments on
      the blob: import URL because blob urls can't have a query string
    - what about as a data attribute on the import tag?

- when the Fcommand wants to run bg code, it has to post a
  message that is intercepted by the content script, which
  then passes it to bg to run
    - consider a custom event, rather than postMessage, since any message
      handlers will get posted message by default.  This doesn't prevent
      anyone else from also listening to the custom event, but it reduces
      onmessage spam.
    - it includes the Fcommand's guid so the bg page can load that
      Fcommand's bg code and run it, passing it the data it received
      from the posted message
    - it posts a message to the content script containing the
      parameter array to be passed to the bg script.  No token
      needed, no security risk beyond what's already inherent.  No
      need for a response function that must be called.
    - while it would be nice to call
      chrome.runtime.sendMessage() and listen for external
      messages within the content script (because postMessage
      goes to all listeneres, while sendMessage() goes only to
      the extension), sendMessage() requires a non-wildcard,
      second-level domain to be whitelisted in the manifest.
      This is obviously not possible for Fcommands (which can run
      anywhere).

- could listen for omnibox event onInputStarted and show the info that
  commands can't be run on internal pages
    - however, this only matters if they're running a non-bg fcommand, so
      you can't know this when input has started, only once the set of
      possible fcommands is known
    - onInputEntered's callback specifies if the tab is current, new fg or
      new bg;  that info should be available to the Fcommand/bg script

- would be cool to flag an fcommand as taking no parameters and being able
  to be run from the context menu.  Then we can populate the context menu
  with those Fcommands and when you click one, it runs it as if you had
  typed its name in the omnibox

- could just use the chrome filesystem sync api to store the factotum
  commands on the user's google drive and then make them available in all
  clients
    - should be able to toggle which ones you want sync'd and which you
      don't (so you can have a set of scripts just for work that aren't
      sync'd to your home account)?  Or just handle this via chrome profiles?

- should the DB have a separate table of guid->code, rather than storing the
  code in the same table as the metadata?
    - if separate, you only ever read in the code for the function about to
      be executed, saving memory.  Whereas if the code is in the same table,
      then when getting commands by prefix (or even when listing all
      commands), you have to pull all the code as well, even if it's not
      going to be used, which is wasteful.

- create class that manages Fcommands  FcommandManager
    - Fcommands are stored in an IndexedDB
      - indexed on unique guid
      - indexed on name
    - constructor
        - sets up objectstore and indexes
    - addCommand
        - saves the given Fcommand
    - deleteCommand
        - removes the given Fcommand
    - getCommandsByName
        - returns list of Fcommand objects given a name.

- Fcommand datastore
    - names[] : indexed
    - guid : indexed, unique key
    - original document string
    - description
    - optSpec
    - help document string?
    - cooked document string?
    - all of the metadata fields (if showing them separately, might as well
      make them separate fields, although it seems silly to store the
      original document then duplicate all its data in separate fields)
    - enabled
    - priority[]: integer associated with name[].  Lower number == highest
      priority.  Priorities are per name, not per Fcommand (i.e. you may have 2 Fcommands with the name "foo", and you want one to have higher priority than the other.  Priority is used only to determine the order of the Fcommand names in the omnibox dropdown)


----------------


- provide a management interface on the options page just for F commands
    - shows a list of commands
    - support enabling/disabling F commands
    - support enable/disable of individual aliases for Fcommands???
        - useful if you have an Fcommand that supplies an alias you don't
          want because it's supplied by a different Fcommand
    - shows their help content
    - editing commands
    - exporting commands

- internal Fcommand 'help' should pull up the help content for the given
  Fcommand
    - do this with a default --help option on an Fcommand

- support commands from non-local sources
    - e.g. specifying a URL will pull the Fcommand from the URL and use it.
        - need to specify the data format.
    - can these be edited locally???

- popup page could show the last N Fcommands and/or the most frequently used
  Fcommands

- need an option to toggle error notifications on/off?

- useful to make distinction between commands that require the current
  page's context and those that don't?
    - e.g. if an Fcommand is only opening a new tab, there's no need for it
      to run within the current page--it can run fine in the background page
    - too difficult to explain to users?

- fcommand's response object could have an extra field that if somehow set
  by the Fcommand's code (and the code succeeded) would indicate the
  extension should popup a notification with custom content.

- explore using a page action instead of a browser action for Factotum,
  since it (currently) requires a page in order to do pretty much anything.
  It would be great if there is a way to trigger the page action popup
  (since it's not possible to trigger it for the browser action).  Then it
  could be used for notifications, return statuses, etc.

- thinking internal Fcommands should be handled entirely differently.  They
  don't exist as Fcommands.  They're hardcoded and cannot be overridden or
  reprioritized.  There aren't many of them (maybe even only "help").  They are
  detected when the command line is parsed and before it is dispatched.
  This simplifies the Fcommand.execute property logic.

- should supply handy notification icons so bg code can easily pop a
  notification using standard icons included in the extension (then there's
  no cross-origin issues).  Makes sense to expose the internal URLs, since
  the extension will need them anyway.

About the importing

DONE
- while there is no reason to import the exact document as given, it is
  easiest to import the entire thing.  A future optimization could
  extract and remove some data, yielding a smaller document for import.
