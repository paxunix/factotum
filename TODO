- how to support multiple languages where it matters?
    - since the Fcommand doc is an HTML5 document, all the usual lang
      attributes apply.  This probably should govern which tags we pull from
      the doc when surfacing its data.

- is it feasible/sensible to use HTML imports to do the actual JS importing?
  Also for any external resources the injected script requires?  Maybe
  bundle the whole set up in a document and import the doc?
    - can import a data URL?  Doesn't seem to be possible (Chrome complained
      with net::ERR_INVALID_URL

- what if the Fcommands were actually HTML documents?
    - when installed, they're written to a filesystem object
    - when run, that file system object is used as an href and imported into
      the current document
        - what if you want to import it into the background page?  Or an
          arbirary background page?  Can you dynamically create a background
          page?
    - or just save them as a Blob into an indexeddb (supported as of Chrome
      38) and use URL.createObjectURL(blob) to get a URL from it
        - will this work?  if the import is into the background page, it
          will generate URLs with the extension page's origin and probably
          not be importable into the page.
            - probably never import an FCommand into the background page.
              But what if it really just needs extension APIs?  There's no
              need to load it into the content page at all, then pass JS
              back to be executed in background anyway.
    - this leads to really cool things:
        - since the Fcommand is an HTML document, then you can use <meta> to
          specify the metadata for the Fcommand, and programmatically
          extract it.  This should cut down significantly on the validation
          needed for Fcommands:  the browser's document parser does much of
          it already.
            - Factotum's background script will have to create a document
              fragment in order to extract the metadata, but that's a
              one-time fixed cost at first installation of an Fcommand.
                - What about modifying it?  Do we want to support local
                  modifications?
    - then, the document we actually import could even include
      Factotum-specific stuff after, in order to do any additional setup.
    - this handles de-duping of resources, allows for Fcommands to include
      and dependencies they want via the same import mechanism.
    - It seems like everything will just work:  however, if CORS disallows
      us from loading a file or blob URL as an import, we're fucked
        - looks like using a blob, then getting its object URL will work
          just fine on dynamically-created content because the
          createObjectURL() on a blob puts the object into the page's origin
          (and cleans it up when the page is unloaded--or we can call
          revokeURL on it)
    - why use an import document?
        - because then the author can specify all the crazy dependencies
          they want and we don't have to define a special data format to do
          it.  They can even define custom markup that they can then clone
          wholesale into the parent document to use from within their
          Fcommand script.
    - how to handle Fcommands that need extension-level permissions to do
      something, but within the context of a page?  They need to tell the
      background script to do something on their behalf (like execute
      arbitrary JS), and return the results when ready.  This seems mostly
      straightforward:
        - the background script has a listener for requests from the content
          script
        - content script sends a request whose payload is arbitrary JS
        - bg script receives the payload, executes the JS in a sandbox,
          sends the results back to the content script (or to the page?)
    - XXX:  just always run them in a page.  Then you don't need this.
      should be able to import an Fcommand into the background page also, in
      case it requires nothing but extension APIs.  That has to run in some
      kind of sandbox so you can't crash the extension.  May be as simple as
      evaling the script in a sandboxed iframe within the extension's
      background page.
        - seems web workers are also a possibility, although then you don't
          have access to window property (so you basically get no UI stuff).
          http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/
    - so the background page can collect the metadata from the Fcommand
      document with:
              fcommandDoc=jQuery("<div>").append(jQuery.parseHTML(jQuery));
              guid=fcommandDoc.find("meta[name=guid]:first")[0].prop("content");
            in order to extract the data for the IndexedDB tables.
        - can parse HTML using DOMParser:
            doc = (new DOMParser).parseFromString('<div>testing <script>alert("testing");</script> 1 2 3</div>', "text/html");
            - no scripts are evaluated; it just builds the DOM
    - any embedded scripts won't be eval'd in that case (which is what we
      want), but they _will_ be eval'd when injected into the page via
      import.  That's why the Fcommand script itself is marked with a bogus
      mime-type:  you don't want it executed on insertion (XXX:  we're going
      to do this with <template> instead.  Then you _can_ distinguish
      between run-on-import and run-as-fcommand-after-import).  Hmm, or do
      you?
      Actually, you could let it eval as a normal script.  Any other scripts
      were already eval'd (even as imports), and if you need to yoink in
      content from the import, you have to do it anyway when the Fcommand
      runs.  So, it probably makes the most sense to just make the script be
      as-is, no mime-type fuckery.
        - don't need an id on the script tag either, since it's simply going
          to be evaluated in-place during import--no need to reference it
          and eval it later.  Actually, this won't work:  we have no control
          over wrapping it in a script to catch errors, etc.
          So, you still need the fake mime-type script tag with ID, but if
          you emit regular script tags, be aware they will execute upon
          import of the document (this can be handy for some things, like an
          Fcommand to load jQUery into a page and notify when it's done)
          - might be able to remove the Fcommand script from the document
            before importing it; that way you don't bloat the page by
            duplicating it.  Same for the minimist-opts block.
                fcommandbody = impdoc.find("script#fcommand").remove().text();

    - figure out what happens if the content script injects the <link>
      import and it runs a script.  Does the script get run in the
      content-script's context or in the page's context?  This would matter
      if they didn't put <template> in (for which there is a valid reason:
      you're loading a script via import, but you want something done as
      soon as it finishes)
        - this seems obvious:  it has to run in page context since that's
          the document into which it was injected

    - note that the HTML document that contains an Fcommand is just a
      delivery document.  Data is extracted from it and put into a DB and
      then various parts of it are rearranged and injected into other
      documents as needed.
        - there is no need to import the entire document when we had to
          extract data from it and store it anyway.  But does it matter?
          These won't be huge documents.

- need a way to inject into all frames within a page?

- so the content script should be able to pass a function to the bg page,
  which runs it.  That function returns a result back to the content page
  via message passing.  The function itself gets run inside a web worker in
  the bg page (so it has very limited access to the extension, but does have
  access to chrome APIs -- have to test this).
    - this is how you get your content script to, say, open a new tab, or
      make a cross-origin ajax request and get the results

- would be cool to flag an fcommand as taking no parameters and being able
  to be run from the context menu.  Then we can populate the context menu
  with those Fcommands and when you click one, it runs it as if you had
  typed its name in the omnibox

- could just use the chrome filesystem sync api to store the factotum
  commands on the user's google drive and then make them available in all
  clients
    - should be able to toggle which ones you want sync'd and which you
      don't (so you can have a set of scripts just for work that aren't
      sync'd to your home account)?  Or just handle this via chrome profiles?

- should the DB have a separate table of guid->code, rather than storing the
  code in the same table as the metadata?
    - if separate, you only ever read in the code for the function about to
      be executed, saving memory.  Whereas if the code is in the same table,
      then when getting commands by prefix (or even when listing all
      commands), you have to pull all the code as well, even if it's not
      going to be used, which is wasteful.

- create class that manages Fcommands  FcommandManager
    - Fcommands are stored in an IndexedDB
      - indexed on unique guid
      - indexed on name
    - constructor
        - sets up objectstore and indexes
    - addCommand
        - saves the given Fcommand
    - deleteCommand
        - removes the given Fcommand
    - getCommandsByName
        - returns list of Fcommand objects given a name.

- Fcommand datastore
    - names[] : indexed
    - guid : indexed(?), unique key
    - description
    - execute
    - helpHtml
    - optSpec
    - enabled
    - priority:  but this has to be per-name


----------------


- allow for any JS (or CSS) to be loaded into the page (via
  chrome.tabs.executeScript or chrome.tabs.insertCSS).  Each Fcommand gets a
  new property that is an array of things to be injected into the page
  immediately before that command executes.
    - may need to guard against multiple inclusion.
    - what if we inject a minimal loader in-page and use it for inclusions?

- prior to each Fcommand's execution, load any requested additional
  functionality into the current page.

- provide a management interface on the options page just for F commands
    - shows a list of commands
    - support enabling/disabling F commands
    - support enable/disable of individual aliases for Fcommands???
        - useful if you have an Fcommand that supplies an alias you don't
          want because it's supplied by a different Fcommand
    - shows their help content
    - editing commands
    - exporting commands

- internal Fcommand 'help' should pull up the help content for the given
  Fcommand

- support commands from non-local sources
    - e.g. specifying a URL will pull the Fcommand from the URL and use it.
        - need to specify the data format.
    - can these be edited locally???

- support commands that aren't commands at all but are actually JS libs?
  Same for CSS?
    - this provides a mechanism to load common libs locally, rather
      than from an external source upon use.
    - these can be requested for load by an Fcommand; give them aliases?  No
      need: they can just be requested via URL, then cached.
    - cache them?  Then only refresh them whenever the Factotum extension is
      activated?  If so, then maybe it's not necessary to have commands that
      aren't commands--they can be demand-loaded via the above mechanism and
      since they're cached, subsequent loads will be fast.

- popup page could show the last N Fcommands and/or the most frequently used
  Fcommands

- need an option to toggle error notifications on/off?

- since chrome.tabs.executeScript doesn't support remote URLs, we need to do
  an XHR from the background page to pull the script content, then inject
  that into the page

- Fcommand 'execute' property can be a function or a string.  The only time
  it will be a function is if it's an internally-implemented Fcommand,
  because in all other cases, the code will have come from a string.  Since
  that's the case, maybe we only need internal functions to run within the
  background page, rather than the content page.  E.g.  the 'help' Fcommand
  should popup some window with information about the given command.  There
  is no need for it to run in the content page since it won't need access to
  anything there.  Is it true that will be the case for all internal
  Fcommands?
    - actually, it makes a lot of sense to run internal Fcommands from the
      background page:  we want them to be available everywhere, even on
      internal chrome pages (which they actually can't be anyway).
    - this means the _converted_-key stuff can probably go away because any
      internal functions don't need to be persisted (if it's an actual
      function, it is defined by the extension itself and so doesn't need to
      be stored).

- useful to make distinction between commands that require the current
  page's context and those that don't?
    - e.g. if an Fcommand is only opening a new tab, there's no need for it
      to run within the current page--it can run fine in the background page
    - too difficult to explain to users?

- fcommand's response object could have an extra field that if somehow set
  by the Fcommand's code (and the code succeeded) would indicate the
  extension should popup a notification with custom content.

- it may be possible to have the spec runner page load a separate page before
  executing Fcommands.  Then, force that page's tab to be the current tab
  when the test runs.  This will hopefully cause the Fcommand to be run in
  that page, rather than trying (and failing) to run in the spec page.

- explore using a page action instead of a browser action for Factotum,
  since it (currently) requires a page in order to do pretty much anything.
  It would be great if there is a way to trigger the page action popup
  (since it's not possible to trigger it for the browser action).  Then it
  could be used for notifications, return statuses, etc.

- thinking internal Fcommands should be handled entirely differently.  They
  don't exist as Fcommands.  They're hardcoded and cannot be overridden or
  reprioritized.  There aren't many of them (maybe even only "help").  They are
  detected when the command line is parsed and before it is dispatched.
  This simplifies the Fcommand.execute property logic.
